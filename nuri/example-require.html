<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>RequireJS의 간단한 예제</title>
<link rel="stylesheet" type="text/css" href="scripts/ext-3.4.0/resources/css/ext-all.css" media="all" />
<link rel="stylesheet" type="text/css" href="scripts/ext-3.4.0/resources/css/ext-all.css" media="all" />
<link rel="stylesheet" type="text/css" href="css/base.css" media="all" />
</head>
<body>
<div id="wrapper">
	
	<header>
		<h1>도형 그리기</h1>
		<p>각 도형을 모듈이라고 생각합니다.</p>
	</header>
	
	<section id="article-list">
		<div id="loading-indicator">Loading...</div>
		<div id="canvas-container" style="overflow: hidden;">
			<canvas id="canvas" width="400", height="300"></canvas>
		</div>
		<div id="controller-panel" style="border: solid 1px #ccc;">
			<button data-module="circle">원 그리기</button>
			<button data-module="square">사각형 그리기</button>
			<button data-module="triangle">삼각형 그리기</button>
			<button data-module="remove">모두 지우기</button>
		</div>
	</section>
	
	<footer>
		<p>
			간단한 샘플입니다<br/>
			<address><a href="http://blog.javarouka.me/">blog.javarouka.me</a></address>
		</p>
	</footer>

</div>

<!-- page scripts -->
<script type="text/javascript" src="scripts/require-jquery.js"></script>
<script>
$(document).ready(function(e) {

	// require는 코드간 의존성을 정의하는 함수.
	// java의 import 구문이라고 생각하면 된다.
	// 자바와는 다르게 import 후 따로 생성하거나 @Autowired 등으로 
	// DI받을 필요 없이 자동으로 그 모듈이 생성되어 뒤의 함수의 인자로 전달된다.
	// 한번 생성된 모듈은 캐시되어 다시 생성되지 않는 싱글톤 형식이다.
	// 
	// 이 코드는 jQuery가 필요하며 jQuery를 서버에서 다운로드받아 페이지에 로드하기
	// 전까지 대기하겠다는 뜻이다.
	// 인자의 이름은 뭘 줘도 상관없지만 편의상 $를 사용하였다.
	require([ "jquery" ], function($) {

		$("#loading-indicator").hide('slow');

		$container = $("#canvas-container");
		$controllerPanel = $("#controller-panel");
		$buttons = $controllerPanel.find("button");

		var doWork = function(e) {
			var $target = $(e.target);

			var workPart = $target.attr("data-module");
			var workName = "scripts/samples/" + workPart;

			// require를 사용하여 코드 중간에 자바스크립트 파일을 비동기 로딩한다.
			// 지정된 파일이 로드되기 전까지는 아래 코드는 수행되지 않고 블럭된다.
			// 그렇다고 화면이 멈추는건 아니고 
			// 모듈 로딩이 Ajax 처럼 비동기적으로 수행될 뿐이다.
			// 해당 모듈은 한번 로딩되고 수행되고 나면 다시는 다시 생성되지 않고,
			// 다시 로드할 경우 예전에 로드된 모듈이 반환된다.
			// 
			// 원 그리기 버튼을 눌렀을 경우, 모듈 이름은 scripts/samples/circle 이 되며
			// 경로 이름은 //{컨텍스트}/nuri/scripts/samples/circle.js 이 된다.
			//
			// 스프링 프레임워크의 ApplicationContext에 등록된 빈같은 싱글톤이 된다.
			require([ workName ], function(Work) {

				// 행동 조사 타입식별(Duck-Typing)으로 모듈의 인터페이스를 구분한다.

				// 그리기 모듈일 경우 빌드작업을 수행
				if(Work.paint) {
					var buildedModule = Work.paint($container, function() {

					});					
				}

				// 수행 모듈일 경우 액션을 실행
				if(Work.execute) {
					Work.execute($container);
				}				
			});
		};

		var eventBinding = function() {
			$buttons.bind("click", doWork);
		};

		eventBinding();

	});

})
</script>
</body>
</html>